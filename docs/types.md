# Sentinel Orchestrator Type System

This document provides comprehensive documentation of all types in the Sentinel Orchestrator domain model.

## Table of Contents

- [Core Types](#core-types)
  - [MessageId](#messageid)
  - [AgentId](#agentid)
  - [Role](#role)
  - [AgentState](#agentstate)
  - [CanonicalMessage](#canonicalmessage)
- [Request/Response Types](#requestresponse-types)
  - [ChatCompletionRequest](#chatcompletionrequest)
  - [ChatCompletionResponse](#chatcompletionresponse)
  - [TokenUsage](#tokenusage)
  - [AgentStatus](#agentstatus)
  - [HealthStatus](#healthstatus)
  - [ErrorResponse](#errorresponse)
- [Error Types](#error-types)
  - [SentinelError](#sentinelerror)
- [Trait Definitions](#trait-definitions)
  - [LLMProvider](#llmprovider)
  - [VectorStore](#vectorstore)
- [Type Relationships](#type-relationships)
- [Serialization](#serialization)
- [Validation Rules](#validation-rules)

## Core Types

### MessageId

Unique identifier for a message (NewType pattern wrapping UUID).

```rust
pub struct MessageId(pub Uuid);
```

**Properties**:
- Wraps a `Uuid` (v4)
- Implements: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Display`
- JSON serialization: Transparent (serializes as UUID string)

**Methods**:
- `new() -> MessageId`: Generate a new MessageId with UUID v4
- `default() -> MessageId`: Alias for `new()`

**Conversions**:
- `From<Uuid> for MessageId`
- `From<MessageId> for Uuid`

**Example**:
```rust
use sentinel::core::types::MessageId;

let id = MessageId::new();
let uuid: Uuid = id.into();
let id_from_uuid = MessageId::from(uuid);
```

**JSON Format**:
```json
"123e4567-e89b-12d3-a456-426614174000"
```

### AgentId

Unique identifier for an agent/actor (NewType pattern wrapping UUID).

```rust
pub struct AgentId(pub Uuid);
```

**Properties**:
- Wraps a `Uuid` (v4)
- Implements: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`, `Display`
- JSON serialization: Transparent (serializes as UUID string)

**Methods**:
- `new() -> AgentId`: Generate a new AgentId with UUID v4
- `default() -> AgentId`: Alias for `new()`

**Conversions**:
- `From<Uuid> for AgentId`
- `From<AgentId> for Uuid`

**Example**:
```rust
use sentinel::core::types::AgentId;

let agent_id = AgentId::new();
```

**JSON Format**:
```json
"123e4567-e89b-12d3-a456-426614174001"
```

### Role

Role of a message participant.

```rust
pub enum Role {
    User,      // User-sent message
    Assistant, // Assistant/AI-generated message
    System,    // System/context-setting message
}
```

**Properties**:
- Implements: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`
- JSON serialization: Lowercase strings (`"user"`, `"assistant"`, `"system"`)

**Variants**:
- `User`: Messages sent by the user/client
- `Assistant`: Messages generated by the AI assistant
- `System`: System messages for context-setting (e.g., instructions, personality)

**JSON Format**:
```json
"user" | "assistant" | "system"
```

**Example**:
```rust
use sentinel::core::types::Role;

let user_role = Role::User;
let assistant_role = Role::Assistant;
let system_role = Role::System;
```

### AgentState

Agent state in the state machine.

```rust
pub enum AgentState {
    Idle,      // Agent is idle, waiting for messages
    Thinking,  // Agent is processing/thinking
    ToolCall,  // Agent is calling a tool
    Reflecting, // Agent is reflecting on results
}
```

**Properties**:
- Implements: `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`
- JSON serialization: Lowercase strings (`"idle"`, `"thinking"`, `"toolcall"`, `"reflecting"`)

**State Transitions**:
Valid transitions:
- `Idle → Thinking`: Message received, starting processing
- `Thinking → ToolCall`: Decided to call a tool
- `ToolCall → Reflecting`: Tool call completed, processing results
- `Reflecting → Idle`: Reflection complete, returning to idle
- Self-transitions are always allowed (state can remain unchanged)

Invalid transitions:
- Any transition not listed above
- Backwards transitions (e.g., `Thinking → Idle`)
- Skipping states (e.g., `Idle → ToolCall`)

**Methods**:
- `validate_transition(from: AgentState, to: AgentState) -> Result<(), SentinelError>`: Validate if a state transition is allowed

**JSON Format**:
```json
"idle" | "thinking" | "toolcall" | "reflecting"
```

**Example**:
```rust
use sentinel::core::types::AgentState;

// Valid transition
assert!(AgentState::validate_transition(
    AgentState::Idle,
    AgentState::Thinking
).is_ok());

// Invalid transition
assert!(AgentState::validate_transition(
    AgentState::Idle,
    AgentState::Reflecting
).is_err());
```

### CanonicalMessage

Canonical message format - the core domain type for all message communication.

```rust
pub struct CanonicalMessage {
    pub id: MessageId,
    pub role: Role,
    pub content: String,
    pub timestamp: DateTime<Utc>,
    pub metadata: HashMap<String, String>,
}
```

**Properties**:
- Pure Rust type with no external dependencies
- Implements: `Debug`, `Clone`, `PartialEq`, `Eq`, `Serialize`, `Deserialize`
- JSON serialization: Standard object format

**Fields**:
- `id: MessageId`: Unique identifier for this message
- `role: Role`: Role of the message sender (`User`, `Assistant`, `System`)
- `content: String`: Message content (must not be empty after trimming)
- `timestamp: DateTime<Utc>`: Timestamp when message was created (ISO 8601, UTC)
- `metadata: HashMap<String, String>`: Optional metadata (key-value pairs, defaults to empty map)

**Validation Rules**:
- `content`: Must not be empty after trimming whitespace
- `timestamp`: Must be valid ISO 8601 format, not more than 1 hour in the future, not more than 100 years in the past
- `id`: Must be a valid UUID (enforced by type)

**Methods**:
- `new(role: Role, content: String) -> CanonicalMessage`: Create a new message with current timestamp
- `with_timestamp(role: Role, content: String, timestamp: DateTime<Utc>) -> CanonicalMessage`: Create a message with explicit timestamp (for replay/testing)
- `with_metadata(role: Role, content: String, metadata: HashMap<String, String>) -> CanonicalMessage`: Create a message with metadata
- `validate(msg: &CanonicalMessage) -> Result<(), SentinelError>`: Static validation method
- `validate_self(&self) -> Result<(), SentinelError>`: Instance validation method
- `is_empty(&self) -> bool`: Check if content is empty (after trimming)
- `content_len(&self) -> usize`: Get the length of the content string

**JSON Format**:
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174000",
  "role": "user",
  "content": "Hello, how are you?",
  "timestamp": "2025-01-20T10:00:00Z",
  "metadata": {
    "source": "web",
    "version": "1.0"
  }
}
```

**Example**:
```rust
use sentinel::core::types::{CanonicalMessage, Role};

// Create a new message
let msg = CanonicalMessage::new(
    Role::User,
    "Hello, world!".to_string()
);

// Validate the message
msg.validate_self()?;

// Create with metadata
let mut metadata = HashMap::new();
metadata.insert("source".to_string(), "api".to_string());
let msg_with_meta = CanonicalMessage::with_metadata(
    Role::User,
    "Hello".to_string(),
    metadata
);
```

## Request/Response Types

### ChatCompletionRequest

Request format for chat completion endpoint.

```rust
pub struct ChatCompletionRequest {
    pub messages: Vec<CanonicalMessage>,
    pub model: Option<String>,
    pub temperature: Option<f64>,
    pub max_tokens: Option<u32>,
    pub stream: bool,
}
```

**Fields**:
- `messages: Vec<CanonicalMessage>`: Required. List of messages in the conversation
- `model: Option<String>`: Optional. Model to use (defaults to configured model)
- `temperature: Option<f64>`: Optional. Sampling temperature (0.0-2.0)
- `max_tokens: Option<u32>`: Optional. Maximum tokens to generate
- `stream: bool`: Optional. Stream responses (default: `false`)

**JSON Format**:
```json
{
  "messages": [...],
  "model": "gpt-4",
  "temperature": 0.7,
  "max_tokens": 1000,
  "stream": false
}
```

### ChatCompletionResponse

Response format for chat completion endpoint.

```rust
pub struct ChatCompletionResponse {
    pub message: CanonicalMessage,
    pub model: String,
    pub usage: Option<TokenUsage>,
}
```

**Fields**:
- `message: CanonicalMessage`: Generated message
- `model: String`: Model used for generation
- `usage: Option<TokenUsage>`: Optional token usage information

**JSON Format**:
```json
{
  "message": {...},
  "model": "gpt-4",
  "usage": {
    "prompt_tokens": 100,
    "completion_tokens": 50,
    "total_tokens": 150
  }
}
```

### TokenUsage

Token usage information.

```rust
pub struct TokenUsage {
    pub prompt_tokens: u32,
    pub completion_tokens: u32,
    pub total_tokens: u32,
}
```

**Fields**:
- `prompt_tokens: u32`: Number of tokens in the prompt
- `completion_tokens: u32`: Number of tokens in the completion
- `total_tokens: u32`: Total tokens used (should equal `prompt_tokens + completion_tokens`)

**JSON Format**:
```json
{
  "prompt_tokens": 100,
  "completion_tokens": 50,
  "total_tokens": 150
}
```

### AgentStatus

Agent status information.

```rust
pub struct AgentStatus {
    pub id: AgentId,
    pub state: AgentState,
    pub last_activity: DateTime<Utc>,
    pub messages_processed: u64,
}
```

**Fields**:
- `id: AgentId`: Agent identifier
- `state: AgentState`: Current agent state
- `last_activity: DateTime<Utc>`: Last activity timestamp
- `messages_processed: u64`: Number of messages processed by this agent

**JSON Format**:
```json
{
  "id": "123e4567-e89b-12d3-a456-426614174001",
  "state": "idle",
  "last_activity": "2025-01-20T10:00:00Z",
  "messages_processed": 42
}
```

### HealthStatus

Health check response.

```rust
pub struct HealthStatus {
    pub status: HealthState,
    pub timestamp: DateTime<Utc>,
}

pub enum HealthState {
    Healthy,
    Ready,
    Alive,
    Unhealthy,
}
```

**JSON Format**:
```json
{
  "status": "healthy",
  "timestamp": "2025-01-20T10:00:00Z"
}
```

### ErrorResponse

Error response format.

```rust
pub struct ErrorResponse {
    pub code: String,
    pub message: String,
    pub details: Option<HashMap<String, String>>,
}
```

**JSON Format**:
```json
{
  "code": "INVALID_REQUEST",
  "message": "Invalid request format",
  "details": {
    "field": "messages",
    "reason": "Cannot be empty"
  }
}
```

## Error Types

### SentinelError

Domain error enum using `thiserror`.

```rust
pub enum SentinelError {
    InvalidStateTransition { from: AgentState, to: AgentState },
    InvalidMessage { reason: String },
    DomainViolation { rule: String },
}
```

**Variants**:
- `InvalidStateTransition`: Attempted invalid state transition
- `InvalidMessage`: Message validation failed
- `DomainViolation`: Domain rule violation

**Properties**:
- Implements: `Error`, `Debug`, `Clone`, `PartialEq`, `Eq`
- Generated via `thiserror::Error`

**Example**:
```rust
use sentinel::core::error::SentinelError;
use sentinel::core::types::AgentState;

let error = SentinelError::InvalidStateTransition {
    from: AgentState::Idle,
    to: AgentState::Reflecting,
};
```

## Trait Definitions

### LLMProvider

Trait for LLM (Large Language Model) providers.

```rust
#[async_trait]
pub trait LLMProvider: Send + Sync {
    async fn complete(
        &self,
        messages: Vec<CanonicalMessage>,
    ) -> Result<CanonicalMessage, SentinelError>;

    async fn stream(
        &self,
        messages: Vec<CanonicalMessage>,
    ) -> Result<Box<dyn Stream<Item = Result<String, SentinelError>> + Send + Unpin>, SentinelError>;
}
```

**Methods**:
- `complete()`: Complete a conversation, returning a single response
- `stream()`: Stream a conversation, returning chunks of the response

**Implementations**:
- `OpenAIClient` (in `src/adapters/openai.rs`)

### VectorStore

Trait for vector storage (embedding databases).

```rust
#[async_trait]
pub trait VectorStore: Send + Sync {
    async fn upsert(
        &self,
        id: MessageId,
        embedding: Vec<f32>,
        metadata: HashMap<String, String>,
    ) -> Result<(), SentinelError>;

    async fn search(
        &self,
        query_embedding: Vec<f32>,
        limit: usize,
    ) -> Result<Vec<MessageId>, SentinelError>;
}
```

**Methods**:
- `upsert()`: Insert or update a vector embedding with metadata
- `search()`: Search for similar vectors using a query embedding

**Implementations**:
- `WeaviateRepo` (planned, in `src/adapters/weaviate.rs`)
- Currently uses `QdrantRepo` (in `src/adapters/qdrant.rs`)

## Type Relationships

```
CanonicalMessage
├── id: MessageId
├── role: Role
├── content: String
├── timestamp: DateTime<Utc>
└── metadata: HashMap<String, String>

ChatCompletionRequest
└── messages: Vec<CanonicalMessage>

ChatCompletionResponse
├── message: CanonicalMessage
├── model: String
└── usage: Option<TokenUsage>

AgentStatus
├── id: AgentId
├── state: AgentState
├── last_activity: DateTime<Utc>
└── messages_processed: u64

SentinelError
├── InvalidStateTransition { from: AgentState, to: AgentState }
├── InvalidMessage { reason: String }
└── DomainViolation { rule: String }
```

## Serialization

All types implement `Serialize` and `Deserialize` from `serde`. Serialization follows these conventions:

- **UUIDs**: Serialized as strings (e.g., `"123e4567-e89b-12d3-a456-426614174000"`)
- **Enums**: Serialized as lowercase strings (e.g., `"user"`, `"idle"`)
- **Dates**: Serialized as ISO 8601 strings in UTC (e.g., `"2025-01-20T10:00:00Z"`)
- **Optional fields**: Omitted from JSON if `None` or empty (using `#[serde(skip_serializing_if)]`)

## Validation Rules

### CanonicalMessage Validation

1. **Content**: Must not be empty after trimming whitespace
2. **Timestamp**: Must be valid ISO 8601, not >1 hour in future, not >100 years in past
3. **ID**: Must be valid UUID (enforced by `MessageId` type)

### AgentState Transition Validation

Valid transitions only:
- `Idle → Thinking`
- `Thinking → ToolCall`
- `ToolCall → Reflecting`
- `Reflecting → Idle`
- Self-transitions (same state) are always allowed

All other transitions are invalid and return `SentinelError::InvalidStateTransition`.

---

**See Also**:
- [API Reference](./api.md) - API usage with these types
- [Usage Guide](./usage.md) - Practical examples
- [Backend Architecture](./backend.md) - Implementation details

